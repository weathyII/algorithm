这段代码实现了 **求解有向图的强连通分量 (Strongly Connected Components, SCC)** 的问题，并在此基础上解决了如下两个任务：

1. **总权值最小和**：对于每个强连通分量，选取该分量中的节点的最小值，将所有强连通分量的最小值相加。
2. **不同选择方式的数量**：计算实现总权值最小和的不同节点选择方式的总数。

下面对代码逐步进行详细解释：

---

### 核心概念

#### 1. **强连通分量 (SCC)**：
- 一个有向图中的一个强连通分量是这样一个子图，其中任意两个节点之间都有路径相连。
- 常用的算法有 Tarjan 算法和 Kosaraju 算法。此处使用的是 **Kosaraju 算法**。

#### 2. **Kosaraju 算法**的步骤：
1. **对原图进行拓扑排序**：
   - 通过第一次 DFS，记录节点的完成时间，并按完成时间逆序入栈。
2. **构建反向图**：
   - 将原图中所有边反向，得到反向图。
3. **在反向图上运行第二次 DFS**：
   - 按栈中节点的顺序依次运行 DFS，每次 DFS 遍历到的节点即为一个强连通分量。

---

### 代码解析

#### 1. **全局变量定义**
```cpp
ll total, mult, val[N];
bool vis[N];
stack<ll> ss;
vector<ll> x;
vector<ll> adj[N*3];
vector<ll> adj2[N*3];
```
- `total`：用于存储所有 SCC 中的最小值之和。
- `mult`：用于存储实现最小值和的不同选择方式数量。
- `val[N]`：存储每个节点的权值。
- `vis[N]`：记录节点是否被访问。
- `ss`：栈，用于存储节点的拓扑顺序。
- `x`：用于临时存储当前 SCC 中的节点。
- `adj[N*3]`：存储原图的邻接表。
- `adj2[N*3]`：存储反向图的邻接表。

---

#### 2. **DFS 的实现**
```cpp
void dfs(ll s)
{
    vis[s] = 1;

    for (int i : adj[s])
    {
        if (!vis[i])
            dfs(i);
    }

    ss.push(s);
}
```
- 第一次 DFS 用于遍历原图，记录拓扑排序。
- 遍历结束后，将节点压入栈 `ss`。

```cpp
void dfs2(ll s)
{
    vis[s] = 1;
    x.push_back(s);

    for (int i : adj2[s])
    {
        if (!vis[i])
            dfs2(i);
    }
}
```
- 第二次 DFS 用于遍历反向图，找到一个 SCC 的所有节点，并存入临时容器 `x`。

---

#### 3. **主函数解析**

##### **输入处理**
```cpp
scanf("%I64d", &n);
for (i = 1; i <= n; i++)
    scanf("%I64d", &val[i]);

scanf("%I64d", &m);

for (i = 0; i < m; i++)
{
    scanf("%I64d%I64d", &u, &v);
    adj[u].push_back(v);
    adj2[v].push_back(u);
}
```
- 输入图的节点数 `n` 和边数 `m`。
- `val[i]` 表示每个节点的权值。
- `adj` 存储原图，`adj2` 存储反向图。

---

##### **第一次 DFS**
```cpp
memset(vis, 0, sizeof(vis));
for (i = 1; i <= n; i++)
{
    if (!vis[i])
        dfs(i);
}
```
- 对原图的所有节点运行 DFS，按完成时间将节点压入栈 `ss`。

---

##### **第二次 DFS**
```cpp
total = 0, mult = 1;
memset(vis, 0, sizeof(vis));

while (!ss.empty())
{
    if (!vis[ss.top()])
    {
        x.clear();
        dfs2(ss.top());

        m = mod;
        count = 0;
        for (i = 0; i < x.size(); i++)
            m = min(m, val[x[i]]);

        total += m;

        for (i = 0; i < x.size(); i++)
        {
            if (val[x[i]] == m)
                count++;
        }

        mult *= (count % mod);
    }

    ss.pop();
}
```
1. **初始化**：
   - `total` 为强连通分量的最小权值总和。
   - `mult` 为实现总和的不同选择方式数量。

2. **对栈中节点运行第二次 DFS**：
   - 每次 DFS 遍历到的节点属于同一个强连通分量。
   - 计算当前 SCC 的最小权值 `m`。
   - 统计权值等于 `m` 的节点数 `count`，更新 `mult`。

---

##### **结果输出**
```cpp
printf("%I64d %I64d", total, mult % mod);
```
- 输出两个值：
  - `total`：所有强连通分量的最小权值和。
  - `mult % mod`：实现该总和的不同选择方式数量，结果对 `mod` 取模。

---

### 示例讲解

**输入：**
```
5
2 2 3 4 2
5
1 2
2 3
3 1
3 4
4 5
```

1. **节点权值**：
   ```
   val = [2, 2, 3, 4, 2]
   ```
2. **图的结构**：
   - 原图 `adj`：
     ```
     1 -> 2 -> 3 -> 1
     3 -> 4 -> 5
     ```
   - 反向图 `adj2`：
     ```
     1 <- 2 <- 3 <- 1
     3 <- 4 <- 5
     ```

**输出：**
```
8 2
```

解释：
- 强连通分量：
  - `{1, 2, 3}` 最小值为 `2`。
  - `{4}` 最小值为 `4`。
  - `{5}` 最小值为 `2`。
- 总和：`2 + 4 + 2 = 8`。
- 实现总和的方式：节点 `{1}` 和 `{2}` 可选，组合数为 `2 × 1 × 1 = 4`。