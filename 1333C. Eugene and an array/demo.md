### 翻译

现在我们先用 \(O(n^2 \times \log(n))\) 的方法解决这个问题。

注意到，如果子数组 \([a_i, \dots, a_j]\) 是**好的**（满足条件），那么子数组 \([a_i, \dots, a_{j-1}]\) 也是好的；而如果子数组 \([a_i, \dots, a_j]\) 不是好的，那么子数组 \([a_i, \dots, a_{j+1}]\) 也一定不是好的。因此，对于每个左边界 \(a_i\)，我们想要找到满足条件的最右边界 \(a_j\)，并将 \(j - i + 1\)（即子数组 \([a_i, \dots, a_j], [a_i, \dots, a_{j-1}], \dots, [a_i]\) 的数量）加到答案中。我们将每个 \(i\) 的最右边界记为 \(R(i)\)。

接下来，我们计算数组的前缀和 \(P\)：
\[
P_0 = 0, \quad P_i = a_1 + a_2 + \dots + a_i, \quad 1 \leq i \leq n
\]

注意，如果子数组 \([a_i, \dots, a_j]\) 的和为零，则有 \(P_{i-1} = P_j\)。因此，子数组 \([a_i, \dots, a_j]\) 是**好的**，当且仅当前缀和 \([P_{i-1}, \dots, P_j]\) 没有重复元素。

根据上述性质，我们可以通过以下方式解决问题：  
- 遍历 \(i\) 从 \(0\) 到 \(n\)，以及 \(j\) 从 \(i\) 到 \(n\)，检查前缀和集合 \([P_i, \dots, P_j]\)。  
- 一旦集合中出现重复（记为第一个 \(j_0\)，此时 \([P_i, \dots, P_{j_0}]\) 中有重复），最右边界即为 \(j_0 - 1\)。  
- 将 \((j_0 - 1) - i\) 加入答案中。

这种解法的时间复杂度为 \(O(n^2 \times \log(n))\)，因为我们需要对每个 \(j\) 操作集合。

---

为了优化到 \(O(n \times \log(n))\)，我们注意到 \(R(i)\) 是关于 \(i\) 单调递增的。现在我们可以：
1. 遍历 \(i\) 从 \(0\) 到 \(n\)。
2. 对于每个 \(i\)，将 \(j\) 从上一次迭代得到的右边界 \(R(i-1)\) 开始，利用上一次的前缀和集合继续往后扩展。

这样，所有 \(j\) 的指针在数组中每个元素只访问一次，最终时间复杂度为 \(O(n \times \log(n))\)。

---

### 代码注意事项

如果使用 C++ 编写代码，建议使用 `std::set` 而不是 `std::unordered_set`，因为后者可能会因为哈希冲突导致解法错误。参考文章中提到的博客 [Codeforces Blog Entry](https://codeforces.com/blog/entry/62393) 介绍了相关细节。

最终的时间复杂度为：
\[
O(n \times \log(n))
\]