### 功能
这段代码解决了一个关于字符串转换的问题，目的是最小化将字符串 \( a \) 转换为 \( b \) 所需的操作次数。每次操作可以将一个字符更改为另一个字符，但要求操作可以通过某些规则传递进行，例如 \( a \to b \to c \)。如果 \( a[i] > b[i] \)，则问题无解。

---

### 代码逻辑详解

#### 1. **输入处理**
```cpp
int t;
cin >> t;
while (t--) {
    int n;
    string a, b;
    cin >> n >> a >> b;
    ...
}
```
读取测试用例数量 \( t \) 和每个测试用例的字符串 \( a \) 和 \( b \) 及其长度 \( n \)。

---

#### 2. **构建图与判断无解**
```cpp
bool bad = false;
vector<vector<int>> adj(20);
for (int i = 0; i < n; i++) {
    if (a[i] != b[i]) {
        if (a[i] > b[i]) {
            bad = true;
            cout << "-1" << endl;
            break;
        }
        adj[a[i] - 'a'].push_back(b[i] - 'a');
        adj[b[i] - 'a'].push_back(a[i] - 'a');
    }
}
if (bad) continue;
```

- 如果 \( a[i] > b[i] \)，输出 `-1` 并标记为无解，因为不可能通过规则将较大的字符变为较小的字符。
- 如果 \( a[i] \neq b[i] \)，则在字符 \( a[i] \) 和 \( b[i] \) 之间建立一条双向边，表示 \( a[i] \) 可以通过某些操作变成 \( b[i] \)，反之亦然。

---

#### 3. **计算弱连通分量**
```cpp
vector<bool> mark(20);
function<void(int)> dfs = [&](int u) {
    mark[u] = true;
    for (auto v : adj[u]) {
        if (!mark[v])
            dfs(v);
    }
};
int ans = 20;
for (int i = 0; i < 20; i++) {
    if (!mark[i]) {
        dfs(i);
        ans--;
    }
}
```

- 使用深度优先搜索（DFS）计算图的弱连通分量。
- 初始有 \( 20 \) 个节点（字母表大小），每找到一个未访问节点（即新的连通分量），运行 DFS 并将答案减 1。

---

#### 4. **输出结果**
```cpp
cout << ans << endl;
```

最终答案是 \( 20 - \text{连通分量数量} \)，即最少操作数。

---

### 时间复杂度
1. **构建图**：遍历字符串 \( a \) 和 \( b \)，复杂度 \( O(n) \)。
2. **DFS**：最多运行 \( 20 \) 次，每次最多访问 \( 20 \) 条边，复杂度 \( O(20 + \text{边的数量}) \)。
3. **总体复杂度**：\( O(n + 20) \)，对于多组测试用例，总复杂度为 \( O(T \times n) \)。

---

### 总结
这段代码利用图的弱连通分量来确定最少操作数。如果无解，则直接输出 `-1`。对于每个测试用例，构图和计算连通分量的操作高效且直观。