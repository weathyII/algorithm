以下是使用 C++ 实现的解决方案，基于异或运算和按位操作的核心思想：

---

### **算法思路**
1. 计算 \( l \oplus r \) 来找出 \( l \) 和 \( r \) 在二进制表示中最高位的不同位置。
2. 确定最高不同位的位数 \( k \)，并计算 \( 2^{k+1} - 1 \) 作为最大异或值。

---

### **代码实现**

```cpp
#include <iostream>
using namespace std;

long long maximumXor(long long l, long long r) {
    // 计算 l 和 r 的异或值
    long long xorVal = l ^ r;
    
    // 用于找到最高不同位
    long long maxXor = 1;
    while (xorVal > 0) {
        maxXor <<= 1;  // 左移一位，相当于乘以2
        xorVal >>= 1;  // 右移一位，减少一位
    }
    
    // 返回最大异或值
    return maxXor - 1;
}

int main() {
    long long l, r;
    cin >> l >> r;  // 输入 l 和 r
    cout << maximumXor(l, r) << endl;  // 输出最大异或值
    return 0;
}
```

---

### **运行示例**

#### 输入：
```
8 12
```

#### 输出：
```
7
```

---

### **代码解析**
#### 核心逻辑：
1. **计算 \( l \oplus r \)**：
   - 确定 \( l \) 和 \( r \) 的不同位。  
   - 如 \( 8 \) (\(1000\)) 和 \( 12 \) (\(1100\))，\( l \oplus r = 4 \) (\(0100\))。
   
2. **确定最高不同位**：
   - 对 \( l \oplus r \) 持续右移，直到所有位都为 0，同时记录最高不同位。
   
3. **构造最大异或值**：
   - 左移 \( k+1 \) 次构造 \( 2^{k+1} \)，减 1 得到最大值，如 \( 7 \) (\(0111\))。

---

### **复杂度分析**
- **时间复杂度**：\( O(\log(r)) \)
  - 取决于 \( r \) 的二进制长度，每次右移一位，处理 \( \log_2(r) \) 次。
- **空间复杂度**：\( O(1) \)
  - 仅使用常量空间变量。

---

### **示例分析**

#### 示例 1
输入：
```
l = 8, r = 12
```
计算步骤：
1. \( l \oplus r = 8 \oplus 12 = 4 \)（\(0100\)）。
2. 最高不同位为第 2 位（从 0 开始）。
3. 最大异或值为 \( 2^{2+1} - 1 = 7 \)（\(0111\)）。

输出：
```
7
```

---

### **扩展与注意事项**
- 输入范围在 \( 1 \leq l \leq r \leq 10^{18} \)，本代码通过 \( long long \) 处理大范围整数。
- 确保使用 `cin` 和 `cout` 以避免超大数读取的格式问题。