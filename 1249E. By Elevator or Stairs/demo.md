下面对这段代码进行逐步解释，这段代码利用动态规划解决了一个“走楼梯或乘电梯”的问题（也称“楼梯与电梯”问题），目标是求从第 1 层到第 n 层的最小耗时/花费，每一层之间可以选择走楼梯或者乘电梯，每种方式有不同的花费，而且乘电梯时需要额外支付一个固定的花费 \(c\)（当切换到电梯模式时）。

### 输入说明

1. **读取输入参数**
   ```cpp
   int n, c;
   cin >> n >> c;
   ```
   - `n` 表示楼层数。
   - `c` 表示切换到电梯所需要额外支付的固定花费。

2. **读取楼梯花费数组**
   ```cpp
   vector<int> a(n);
   for (int i = 1; i < n; i++) {
       cin >> a[i];
   }
   ```
   - 数组 `a` 用于存储走楼梯从第 \(i\) 层到第 \(i+1\) 层所需要的花费。注意这里下标从 1 开始，意味着 `a[1]` 表示从 1 层到 2 层的花费，依此类推。

3. **读取电梯花费数组**
   ```cpp
   vector<int> b(n);
   for (int i = 1; i < n; i++) {
       cin >> b[i];
   }
   ```
   - 数组 `b` 用于存储乘电梯从第 \(i\) 层到第 \(i+1\) 层所需要的花费。类似地，`b[1]` 表示从 1 层到 2 层的花费。

### 动态规划状态定义

使用一个二维动态规划数组 `dp`：
```cpp
vector<vector<int>> dp(n+1, vector<int>(2, 1e9));
```
- `dp[i][0]` 表示到达第 \(i\) 层且当前处于“走楼梯”状态时的最小总花费。
- `dp[i][1]` 表示到达第 \(i\) 层且当前处于“乘电梯”状态时的最小总花费。

初始状态：
```cpp
dp[1][0] = 0;   // 从1层开始，如果选择走楼梯，花费为0
dp[1][1] = c;   // 从1层开始如果选择电梯，需先支付电梯额外花费 c
```
- 注意：虽然在第1层乘电梯没有移动，但题目中通常规定若一开始选择乘电梯，则需要额外支付一次 \(c\) 。

### 状态转移

从第2层开始依次计算，每次都考虑两种状态的转移：

1. **走楼梯状态转移**
   ```cpp
   dp[i][0] = min(dp[i-1][0] + a[i-1], dp[i-1][1] + a[i-1]);
   ```
   - 无论前一层是在走楼梯状态还是乘电梯状态，都可以选择走楼梯上来，代价均为上一次的最小花费加上走楼梯的花费 `a[i-1]`。

2. **乘电梯状态转移**
   ```cpp
   dp[i][1] = min(dp[i-1][0] + b[i-1] + c, dp[i-1][1] + b[i-1]);
   ```
   - 如果前一层处于走楼梯状态，现在切换到乘电梯，那么需要支付电梯花费 `b[i-1]` 和额外的切换费用 `c`。
   - 如果前一层已经处于乘电梯状态，则只需要支付电梯花费 `b[i-1]`。

### 输出结果

代码在每一层输出从第1层到当前层的最小总花费：
```cpp
cout << 0 << " ";
for (int i = 2; i <= n; i++) {
    // 计算 dp[i][0] 和 dp[i][1]（参见上面的状态转移）
    cout << min(dp[i][0], dp[i][1]) << " ";
}
```
- 从第 1 层开始，花费为 0，因此首先输出 `0`。
- 对于每一层 \(i\)（从 2 到 \(n\)），输出两种选择（走楼梯和乘电梯）中更小的那个值，即当前层的最小累计花费。

### 总结

- **问题本质**：在每一层都有两种选择（走楼梯或乘电梯），且切换到电梯需要额外支付一次费用。使用动态规划求解每一层到达的最小花费。
- **状态表示**：`dp[i][0]` 与 `dp[i][1]` 分别表示在第 \(i\) 层选择不同的方式所需的最小花费。
- **状态转移**：从上一层转移到当前层时，选择相应的花费（走楼梯或乘电梯），并考虑是否需要支付额外的电梯费用 \(c\)。

这样，整个程序逐层计算出从第 1 层到每一层的最小花费，并依次输出。