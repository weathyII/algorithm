这个程序的目标是判断给定的无向图是否是二分图（二部图），并在确定为二分图的情况下，为图中的边分配二分图的两个部分。

---

### **程序流程和逻辑：**

#### **1. 定义和初始化：**
- `N`：定义了图的最大顶点数（200,000）。
- `n, m`：`n`是图的顶点数，`m`是图的边数。
- `g`：邻接表形式存储图的边。
- `e`：记录图的边，用于后续的边遍历和输出。
- `bipartite`：用于表示图是否是二分图。
- `color`：记录每个顶点的颜色，用于二分图的验证和边的分类。

---

#### **2. 深度优先搜索（DFS）检测二分图：**
- **函数 `dfs(int v, int c)`：**
  - **参数：**
    - `v`：当前访问的节点。
    - `c`：当前节点的颜色（0 或 1）。
  - **功能：**
    - 将当前节点 `v` 的颜色设置为 `c`。
    - 遍历节点 `v` 的所有邻接节点 `to`：
      - 如果 `to` 未被访问（`color[to] == -1`），递归调用 `dfs`，并将颜色设置为 `c^1`（与当前节点颜色相反）。
      - 如果 `to` 已被访问且颜色与当前节点相同，说明图不是二分图，标记 `bipartite = false` 并返回。

---

#### **3. 主程序：**
- 读取顶点数 `n` 和边数 `m`。
- 读取 `m` 条边的信息，并构建邻接表 `g` 和边列表 `e`。
- 初始化 `color` 数组为 `-1`，表示所有节点未被访问。
- 调用 `dfs(0, 0)` 从节点 0 开始搜索并尝试对图进行染色。
- **输出判断结果：**
  - 如果 `bipartite` 为 `false`，输出 `"NO"` 并结束程序。
  - 如果 `bipartite` 为 `true`，输出 `"YES"`，并输出边的分组信息。

---

#### **4. 输出边的分组：**
- 对于每条边 `(x, y)`：
  - 如果 `color[x] < color[y]`，输出 `1`。
  - 否则，输出 `0`。
- 这部分通过二分图的顶点染色结果，对边进行分类。

---

### **关键逻辑分析：**
- **判断二分图的依据：**
  - 二分图要求图的任意一条边的两个端点颜色不同（`color[v] != color[to]`）。
- **DFS 的实现：**
  - 每次递归染色一个顶点并检查邻接点是否可以被合法染色。
  - 如果遇到染色冲突（两个邻接点颜色相同），立即判定为非二分图。
- **边分类：**
  - 根据顶点颜色的大小（0 或 1），判断边的方向，输出二分图的一种可能性。

---

### **输入输出示例：**

#### 输入：
```
3 3
1 2
2 3
3 1
```

#### 输出：
```
NO
```
- 解释：这是一张环图，包含奇数个节点（3个），因此不是二分图。

---

#### 输入：
```
4 4
1 2
2 3
3 4
4 1
```

#### 输出：
```
YES
0101
```
- 解释：这是一张环图，包含偶数个节点（4个），是二分图。输出的边的分组（`0101`）是合法的分配。

---

### **复杂度分析：**
- **时间复杂度：**  
  - 构建图：`O(m)`，`m` 是边数。
  - DFS：`O(n + m)`，每个顶点和边都被访问一次。
  - 总计：`O(n + m)`。
- **空间复杂度：**  
  - 邻接表存储：`O(n + m)`。
  - 辅助数组（`color` 等）：`O(n)`。
  - 总计：`O(n + m)`。