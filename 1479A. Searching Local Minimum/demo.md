### 程序功能概述

这段程序实现了一个交互式算法，用来在隐藏的排列 \(a_1, a_2, \dots, a_n\) 中找到一个局部最小值。它使用二分查找的方法，通过逐步缩小搜索范围，在最多 100 次查询内定位局部最小值。

---

### 程序逻辑详解

1. **初始化与输入**：
   ```cpp
   cin >> n;
   ll i = 1, j = n, m;
   for (int i = 1; i <= n; i++) arr[i] = 0;
   arr[0] = arr[n + 1] = INT_MAX;
   ```
   - 输入 \(n\)，表示排列的长度。
   - 初始化数组 `arr` 用于缓存查询结果，避免重复查询。数组的两个哨兵值 \(arr[0]\) 和 \(arr[n+1]\) 被设置为 \(+\infty\) (`INT_MAX`)，以便处理边界条件。

2. **查询函数**：
   ```cpp
   void query(ll x) {
       if (x >= 1 && x <= n && arr[x] == 0) {
           cout << "? " << x << endl;
           fflush(stdout);
           cin >> arr[x];
       }
   }
   ```
   - 检查 \(x\) 是否在合法范围内（\(1 \leq x \leq n\)），并且 \(arr[x]\) 是否已经被查询过。
   - 如果未查询，则输出查询指令并读取结果，存储在 `arr[x]` 中。

3. **二分查找主逻辑**：
   ```cpp
   while (i <= j) {
       m = (i + j) / 2;
       query(m);
       query(m - 1);
       query(m + 1);

       if (arr[m] < arr[m - 1] && arr[m] < arr[m + 1]) {
           break;
       } else if (arr[m] > arr[m - 1]) {
           j = m - 1;
       } else {
           i = m + 1;
       }
   }
   ```
   - 使用二分查找定位局部最小值的下标 \(m\)：
     - 计算中间位置 \(m = (i + j) / 2\)。
     - 查询 \(m\) 及其左右邻居的值 \(arr[m-1]\) 和 \(arr[m+1]\)。
     - 检查是否满足局部最小值条件：\(arr[m] < arr[m-1]\) 且 \(arr[m] < arr[m+1]\)。如果满足，则退出循环。
     - 如果 \(arr[m] > arr[m-1]\)，说明左侧存在更小的值，因此调整右边界 \(j = m - 1\)。
     - 否则，调整左边界 \(i = m + 1\)。

4. **输出结果**：
   ```cpp
   cout << "! " << m << endl;
   fflush(stdout);
   ```
   - 找到局部最小值后，输出结果并刷新缓冲区，确保交互程序正常运行。

---

### 关键点解析

1. **边界处理**：
   - 为了避免越界访问，设置了两个哨兵值 \(arr[0] = arr[n+1] = INT_MAX\)。这保证了 \(m = 1\) 或 \(m = n\) 时，比较 \(arr[m]\) 的左右邻居不会出错。

2. **查询优化**：
   - 使用缓存数组 `arr` 来保存查询结果，避免重复查询同一个位置，从而减少不必要的交互次数。

3. **查询次数**：
   - 二分查找每次将搜索范围缩小一半，最多需要 \(O(\log n)\) 次查询。由于 \(n \leq 10^5\)，\(\log n \approx 17\)，完全满足查询次数上限（100 次）的要求。

4. **交互要求**：
   - 每次查询和输出后都需要刷新缓冲区 `fflush(stdout)`，以确保与判题系统的交互顺畅。

---

### 示例运行

#### 输入：
```
5
3 1 4 2 5
```

#### 查询过程：
1. 初始范围 \([1, 5]\)，\(m = 3\)：
   - 查询 \(a_3 = 4\)，\(a_2 = 1\)，\(a_4 = 2\)。
   - \(arr[3] > arr[4]\)，调整范围为 \([4, 5]\)。

2. 新范围 \([4, 5]\)，\(m = 4\)：
   - 查询 \(a_4 = 2\)，\(a_3 = 4\)，\(a_5 = 5\)。
   - \(arr[4] < arr[3]\) 且 \(arr[4] < arr[5]\)，找到局部最小值 \(m = 4\)。

#### 输出：
```
! 4
```