


### 跳过一个陷阱的即时伤害增加

假设当你跳过第 \(i\) 个陷阱时，你立即承受了 \(n-i\) 点伤害（这里 \(n-i\) 表示在此陷阱之后还剩下的陷阱数量。假设之后\(n-i\) 都受到伤害）。  
这样一来，  
- 第一个被跳过的陷阱会比它原本应避免的伤害多出 \(k-1\) 点（因为之后还有 \(k-1\) 个跳跃，每个跳跃都不会受到伤害）；  
- 第二个被跳过的陷阱会多出 \(k-2\) 点；  
- …  
- 最后一个被跳过的陷阱则多出 0 点额外伤害。  

因此，总共增加的伤害为  
\[
\frac{k(k-1)}{2}
\]
这一额外增加的总伤害与具体跳过哪些陷阱无关，所以不影响选择哪几个陷阱跳过。

---


## 问题背景

题目描述：  
- 有 \( n \) 个陷阱（编号 1 到 \( n \)），依次经过。
- 每个陷阱 \( i \)（编号为 \( i \)）若不跳过，则会造成基础伤害 \( a_i \)；  
- 你可以选择跳过最多 \( k \) 个陷阱，跳过某个陷阱则不会受到该陷阱的任何伤害（既不会受到基础伤害，也不会受到后续因跳跃而增加的额外伤害）；  
- 但每当你跳过一个陷阱，从此以后所有未跳过的陷阱伤害都会增加 1（这种增加是累积的）。

观察发现，如果设你选择跳过的陷阱的下标构成集合 \( J \)（下标以 1 为起始编号），那么最终总伤害可以写为：
\[
\text{总伤害} = \sum_{i \notin J} \Bigl(a_i + (\#\text{跳过的陷阱在 } i \text{ 之前的个数})\Bigr).
\]
注意，每个跳过的陷阱都会给之后所有陷阱增加 1 的伤害，而跳过的陷阱本身则完全不计伤害。换一种思路，把“额外伤害”从每个未跳过的陷阱的角度换算成“收益”：  
- 如果你不跳过陷阱 \( i \)，你将受到 \( a_i \) 基础伤害；
- 如果你跳过陷阱 \( i \)，你可以“节省”这 \( a_i \) 点伤害，但代价是该跳跃会使其后所有陷阱的伤害增加 1。因为陷阱 \( i \) 后面一共有 \( n - i \) 个陷阱（注意题目中陷阱编号从 1 到 \( n \)），因此跳过陷阱 \( i \) 会使总伤害增加 \( n - i \)（分摊到后面的陷阱上）。

也就是说，**跳过陷阱 \( i \) 的“净收益”**（damage saved）可以看作：
\[
\text{收益}_i = a_i - (n - i).
\]
为了使最终受到的伤害尽可能少，我们希望通过跳过一些陷阱，**最大化总的“节省”伤害**。因为题目保证使用更多跳跃一定不会使伤害变大（用不完跳跃的话，还可以再跳一个降低伤害），所以我们应当恰好跳 \( k \) 个陷阱。

注意：由于 \( n \) 和 \( i \) 是固定的，所以排序时实际上只需按照 \( a_i + i \)（或更方便的 \( a_i + i+1 \)——因为题目中陷阱编号从 1 开始）来排序。常数项对排序不影响。

---

## 代码详解

下面我们逐行分析代码如何实现上述思路。

### 1. 读入数据并计算基础总伤害

```cpp
int n, k;
cin >> n >> k;
long long ans = 0;
vector<int> a(n);
for (int i = 0; i < n; i++) {
    cin >> a[i];
    ans += a[i];
    a[i] += i + 1;
}
```

- 读入陷阱总数 \( n \) 与最多可跳跃个数 \( k \)。
- 数组 `a` 存放每个陷阱的基础伤害。
- 变量 `ans` 初始化为所有陷阱基础伤害之和，即如果不跳过任何陷阱，受到的伤害为 \(\sum_{i=1}^{n} a_i\)。
- 同时，将每个 \( a[i] \) 修改为：
  \[
  a[i] \leftarrow a[i] + (i+1),
  \]
  其中 \( i+1 \) 就是陷阱的编号。这样修改后，每个元素就变成了  
  \[
  a_i + \text{trap\_index}.
  \]
  
  为什么这样做？  
  正如上面推导的，跳过陷阱 \( i \)（编号 \( i+1 \)）能节省的伤害为
  \[
  a_i - (n - (i+1)).
  \]
  将这一式子改写为
  \[
  a_i + (i+1) - n,
  \]
  可以看出，在排序时，减去的常数 \( n \) 对所有陷阱相同，不影响排序结果。所以可以仅考虑 \( a_i + (i+1) \) 来挑选最优的 \( k \) 个陷阱。

### 2. 排序并挑选最佳的 \( k \) 个陷阱

```cpp
sort(all(a));
reverse(all(a));
for (int i = 0; i < k; i++) ans -= a[i];
```

- 对数组 `a` 进行排序，然后反转（即降序排序），使得排序后的数组前面的元素对应最大的 \( a_i + (i+1) \) 值（即最大的“跳跃收益”）。
- 接着，遍历前 \( k \) 个元素，将它们从总伤害中扣除。这里扣除的是 \( a[i] + (i+1) \) 的值，这相当于我们将这 \( k \) 个陷阱选择为跳跃陷阱，从而节省了它们对应的基础伤害和编号部分。

### 3. 添加因跳跃而增加的额外伤害补偿

```cpp
for (int i = 0; i < k; i++) {
    ans += n;
    ans -= i;
}
```

- 跳过一个陷阱虽然可以省去该陷阱的基础伤害，但每次跳跃都会使后续陷阱的伤害增加。具体来说，跳过陷阱 \( j \)（编号 \( j+1 \)）会使后面所有陷阱增加 1 的伤害，即额外增加的伤害为 \( n - (j+1) \)。
- 由于在排序时我们“丢失”了原来的顺序，为了统一计算，我们在这里补偿了额外增加的伤害。  
- 注意这段代码其实是在为 \( k \) 次跳跃补偿一个统一的项。每次循环中：
  - `ans += n;` 表示每跳一次先加上 \( n \)；
  - `ans -= i;` 由于 \( i \) 从 0 到 \( k-1 \) 变化，这里累计减去 \( 0 + 1 + \cdots + (k-1) = \frac{k(k-1)}{2} \)。
- 综合起来，这部分补偿的总额为
  \[
  k \cdot n - \frac{k(k-1)}{2},
  \]
  正好对应于 \( k \) 跳各自原应补偿的“顺序影响”（因为实际公式中，每个跳跃的净收益应为 \( a_i + (i+1) - n \)，这里减去 \( n \) 后需要补上）。

### 4. 输出答案

```cpp
cout << ans << "\n";
```

- 输出最终计算的最小总伤害。

---

## 思路总结

1. **初始伤害：** 假如不跳任何陷阱，总伤害为所有陷阱基础伤害之和。
2. **跳跃收益：** 跳过陷阱 \( i \) 能节省的伤害为  
   \[
   \text{收益}_i = a_i - \bigl(n - (i+1)\bigr) = a_i + (i+1) - n.
   \]
   为了比较方便，只需比较 \( a_i + (i+1) \) 的大小，因为 \( n \) 是常数。
3. **贪心选取：** 将所有陷阱根据 \( a_i + (i+1) \) 降序排序，选取前 \( k \) 个跳跃能节省最多伤害的陷阱。
4. **结果计算：**  
   - 初始总伤害为所有 \( a_i \) 之和；  
   - 对于选中的每个陷阱，扣除 \( a_i + (i+1) \)；  
   - 补上因跳跃而使后续陷阱伤害增加的额外部分，共计 \( k \cdot n - \frac{k(k-1)}{2} \)。
5. **输出最小总伤害。**

这就是代码的整体思路及其实现细节。
