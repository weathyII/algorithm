下面给出代码的详细解释，包括算法思路和数学证明，帮助你深入理解这一解法。

---

## 问题描述

给定一棵有 \( n \) 个顶点的树，每条边原本都是无向的。现在我们“任意”选择一个顶点（例如顶点 1）作为根，并将所有边按照与根的相对方向赋予颜色：

- 如果一条边从子节点指向父节点（朝根的方向），记为 **红色**；
- 如果一条边从父节点指向子节点（远离根），记为 **绿色**。

输入时，对于每条边 \((u,v)\) ，我们认为给定的顺序表示边的“正确”方向：例如输入 \((u,v)\) 表示边从 \(u\) 指向 \(v\) 为红色。在构建邻接表时，我们将这条边存储在 \( u \) 的列表中时标记为 `true`（红色），而在 \( v \) 的列表中存储时标记为 `false`（绿色）。

我们的目标是：  
**对树中每个顶点 \( v \) 计算如果选 \( v \) 作为首都，需要翻转多少条边，使得从该首都到树中其他所有顶点的路径中——特别是对于路径上应为红色的边和路径外应为绿色的边——达到要求。**  

事实上，可以证明，对于任意顶点 \( v \)，所需翻转的边数仅与从根（顶点 1）到 \( v \) 路径上边的初始状态有关。具体来说，如果我们记：
- \( dp[v] \) 为选顶点 \( v \) 作为首都时，需要翻转的边的总数，
- \( dp[1] \) 为以顶点 1 为首都时需要翻转的边数，

那么就有下面的关系：  
\[
dp[v] = dp[1] + \text{(将树“重新”以 \( v \) 为根时，路径边状态改变所产生的调整)}
\]
通过“重根技巧”（Re-rooting）可以很高效地计算所有 \( dp[v] \)。

---

## 算法步骤

### 1. 构建图

对于输入的每条边 \((u,v)\)：
- 在 `graph[u]` 中添加 \((v, \texttt{true})\)，表示边 \( u\to v \) 是按照输入方向（红色）。
- 在 `graph[v]` 中添加 \((u, \texttt{false})\)，表示反向边 \( v\to u \) 为绿色。

这样构造的图方便在 DFS 时根据父子关系判断“正确”方向与否。

### 2. 第一次 DFS（函数 `dfsone`）：计算以顶点 1 为首都时的翻转次数

从根顶点 1 开始进行 DFS。  
对于 DFS 遍历中每条边 \( (u, v) \)（假设 \( u \) 为父，\( v \) 为子），设：
- 如果在 \( u \) 的邻接表中该边记录为 `true`（红色），则表示该边已经“正确”（不需要翻转）；
- 如果记录为 `false`（绿色），则该边不符合从首都到各顶点路径应为红色的要求，需要翻转，即贡献 1 次翻转。

代码中写法：
```cpp
bool state = !graph[u][i].second;
amount += state;  // 如果 state 为 true，则加 1（需要翻转）
```
这样，`dfsone(1,0)` 返回的值即为 \( dp[1] \)：以顶点 1 为首都时所有从根出发沿 DFS 树的边中需要翻转的总次数。

**数学上解释：**  
定义对于边 \((u,v)\)：
\[
f(u,v)=
\begin{cases}
0, & \text{如果该边是红色（正确）} \\
1, & \text{如果该边是绿色（需要翻转）}
\end{cases}
\]
那么：
\[
dp[1] = \sum_{(u,v) \in \text{DFS树}} f(u,v)
\]
即将整个 DFS 树中所有边的不合要求情况累计起来。

### 3. 第二次 DFS（函数 `dfsall`）：“重根”计算其他顶点作为首都时所需的翻转数

在第一次 DFS 得到 \( dp[1] \) 后，我们利用重根技巧计算所有其他顶点的 \( dp[v] \) 值。  
观察两相邻顶点 \( u \) 和 \( v \)（假设 \( u \) 为父，\( v \) 为子）：
- 当 1 为首都时，边 \( u \to v \) 的贡献是：
  - **若边为红色（即记录为 `true`），** 贡献 0；
  - **若边为绿色（记录为 `false`），** 贡献 1。
- 当将首都从 \( u \) 改为 \( v \) 时，这条边的角色会“反转”：
  - 如果原来该边是红色（即 \( f(u,v)=0 \)），现在它反向（\( v\to u \)）就不符合要求，**需要额外翻转**，即贡献 \( +1 \)。
  - 如果原来该边是绿色（\( f(u,v)=1 \)），则当 \( v \) 成为首都时，这条边正好“对了”，**可以少翻转一遍**，即贡献 \( -1 \)。

因此，定义一个调整函数 \( c(u,v) \) 为：
\[
c(u,v)=
\begin{cases}
+1, & \text{如果边 \( (u,v) \) 为红色（原本不需翻转，但现在需要）} \\
-1, & \text{如果边 \( (u,v) \) 为绿色（原本需翻转，但现在不需翻转）}
\end{cases}
\]
则有重根公式：
\[
dp[v] = dp[u] + c(u,v)
\]
代码实现中：
```cpp
dp[v] = dp[u] + (isRed ? 1 : -1);
```
其中 `isRed` 即表示该边在 \( u \) 的邻接表中记录为 `true`（红色）。

**数学证明：**  
- 设 \( dp[u] \) 是当首都为 \( u \) 时，整棵树中所需翻转的边数。  
- 当将首都从 \( u \) 转移到与 \( u \) 相连的 \( v \) 时，除边 \( (u,v) \) 外，其它边的状态保持不变，只有 \( (u,v) \) 的“贡献”发生改变。  
- 如果 \( (u,v) \) 原本红色（即 \( f(u,v)=0 \)），那么在 \( u \) 为首都时不需翻转；但转为 \( v \) 为首都后，这条边将“逆转”，不再满足“路径上应为红色”的要求，故增加一次翻转。  
- 如果 \( (u,v) \) 原本绿色（\( f(u,v)=1 \)），在 \( u \) 为首都时本来需要翻转；但转为 \( v \) 为首都后，方向正好符合要求，因此可以少翻转一次。  
- 故有：
  \[
  dp[v] = dp[u] + 
  \begin{cases}
  +1, & \text{如果边为红色} \\
  -1, & \text{如果边为绿色}
  \end{cases}
  \]

这一步通过 DFS 遍历整棵树，从根 1 向下传递计算出所有顶点的 \( dp \) 值。

### 4. 求解结果

最后，遍历所有 \( dp[i] \) 得到最小值 \( \min_{i} dp[i] \) 以及所有满足 \( dp[i] = \min \) 的顶点 \( i \)。这就是当选择这些顶点作为首都时，需要翻转的最小边数及对应的顶点。

---

## 总结

- **第一次 DFS（dfsone）：**  
  从顶点 1 出发，统计沿 DFS 树中每条边是否满足“从首都到该顶点的路径上应为红色”。不满足的（即绿色的）需要翻转，累计得出 \( dp[1] \)。

- **重根技巧（dfsall）：**  
  利用重根技巧，从根 1 开始递归更新子节点的 \( dp \) 值：  
  \[
  dp[v] = dp[u] + 
  \begin{cases}
  +1, & \text{如果 \( (u,v) \) 为红色} \\
  -1, & \text{如果 \( (u,v) \) 为绿色}
  \end{cases}
  \]
  证明了当从父顶点 \( u \) 转移到子顶点 \( v \) 时，仅有 \( (u,v) \) 这条边的状态变化会引起翻转次数的差异。

- **数学解释：**  
  通过定义函数 \( f(u,v) \) 表示每条边在初始根下（首都为 1）是否需要翻转，再利用调整因子 \( c(u,v) \) 得到重根公式，从而可以由 \( dp[1] \) 快速推导出所有 \( dp[v] \)。

这种方法仅用两次 DFS 就能计算出每个顶点作为首都时所需的边翻转总数，从而在 \( O(n) \) 时间内解决问题。

---

希望以上的详细解释和数学证明能帮助你充分理解代码的原理与实现！