这个问题要求我们在一个长度为 \( n \) 的整数序列中选取 \( k \) 个不重叠的子数组，每个子数组的长度为 \( m \)，使得这 \( k \) 个子数组的和最大。

### 问题分解

1. **子数组的约束条件**：
   - 我们需要选择 \( k \) 个不重叠的子数组，每个子数组的长度都为 \( m \)。
   - 每个子数组用区间 \([l_i, r_i]\) 表示，且 \( r_i - l_i + 1 = m \)。

2. **目标**：
   - 在满足上述条件的情况下，使这 \( k \) 个子数组的和尽可能大。

3. **输入限制**：
   - \( 1 \leq m \times k \leq n \leq 5000 \)，即序列最多有 5000 个元素。
   - 每个元素的值 \( p_i \leq 10^9 \)，值很大，但元素数量不是特别大，可以用动态规划方法解决。
[[]]
### 解题思路

1. **计算所有长度为 \( m \) 的子数组的和**：
   - 先计算所有长度为 \( m \) 的连续子数组的和，使用滑动窗口技术以保证效率：
     - 首先计算第一个长度为 \( m \) 的子数组的和。
     - 然后滑动窗口，每次将前一个位置的值移除，并添加新的位置的值。

2. **动态规划（DP）设计**：
   - 定义 `dp[i][j]` 表示前 \( i \) 个元素中恰好包含 \( j \) 个不重叠的长度为 \( m \) 的子数组的最大和。
   - `maxSum[i]` 表示以位置 \( i \) 结尾的长度为 \( m \) 的子数组的和。

3. **DP 转移方程**：
   - 对于每个位置 \( i \) 和每个计数 \( j \)：
     - 我们可以选择以 \( i \) 结尾的新子数组，也可以选择不以它结尾。
     - 如果选择它，以 `dp[i - m][j - 1] + maxSum[i]` 更新当前值（其中 `dp[i - m][j - 1]` 是不包含当前子数组的最大和）。

4. **最终结果**：
   - 最终答案保存在 `dp[n][k]` 中，即前 \( n \) 个元素中恰好选取 \( k \) 个不重叠长度为 \( m \) 的子数组的最大和。

### 实现代码

以下是 C++ 实现代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n, m, k;
    cin >> n >> m >> k;

    vector<int> p(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> p[i];
    }

    // 预计算每个长度为 m 的子数组的和
    vector<int> subarraySum(n + 1, 0);
    int currentSum = 0;
    for (int i = 1; i <= n; i++) {
        currentSum += p[i];
        if (i >= m) {
            if (i > m) currentSum -= p[i - m];
            subarraySum[i] = currentSum;
        }
    }

    // 动态规划数组，dp[i][j] 表示前 i 个元素选 j 个子数组的最大和
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));

    for (int j = 1; j <= k; j++) {
        for (int i = j * m; i <= n; i++) {
            // 不选择当前子数组或选择当前子数组
            dp[i][j] = max(dp[i - 1][j], dp[i - m][j - 1] + subarraySum[i]);
        }
    }

    // 输出结果，即前 n 个元素中选 k 个子数组的最大和
    cout << dp[n][k] << endl;

    return 0;
}
```

### 代码解释

1. **输入处理**：
   - 读取 \( n \)、\( m \) 和 \( k \)，并将序列存入 `p` 数组中。

2. **计算子数组和**：
   - 使用滑动窗口计算 `subarraySum[i]`，表示以位置 \( i \) 结尾的长度为 \( m \) 的子数组的和。

3. **动态规划**：
   - `dp[i][j]` 保存前 \( i \) 个元素选取 \( j \) 个不重叠的长度为 \( m \) 的子数组的最大和。
   - 对于每个 \( i \) 和 \( j \)，我们可以选择不包含以 \( i \) 结尾的子数组，或选择包含它，进而更新 `dp[i][j]` 的值。

4. **输出**：
   - 最终的答案即为 `dp[n][k]`。

### 时间复杂度分析

- **时间复杂度**：\( O(n \times k) \)，因为我们对每个位置 \( i \) 进行 \( k \) 次计算。
- **空间复杂度**：\( O(n \times k) \)，用于存储 `dp` 表格和 `subarraySum` 数组。

这样，我们就可以在满足要求的情况下找到最大可能的子数组和。