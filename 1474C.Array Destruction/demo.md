这段代码解决的是一个涉及整数对匹配的问题，具体如下：

---

### **问题描述**

给定一个长度为 \( 2n \) 的数组，要求判断是否可以将其分成 \( n \) 对整数对，使得：
1. 每一对的两个数之和等于当前数组中最大的数 \( x \)。
2. 形成的整数对必须将所有元素都正好用完。

如果可以，输出 "YES"，并打印这些整数对及对应的 \( x \)。否则，输出 "NO"。

---

### **代码逻辑解析**

#### **1. 输入与初始化**
```cpp
int T;scanf("%d",&T);
while(T--){
    read(n);
    s.clear();
    for(int i=1;i<=2*n;i++){
        read(num[i]);
    }
    sort(num+1,num+1+2*n);  // 对数组排序
```
- 输入 \( T \)：测试用例数量。
- 每个测试用例读取 \( n \) 和长度为 \( 2n \) 的数组。
- 对数组进行排序，方便后续从最大值开始尝试匹配。

#### **2. 枚举每种可能的最大值对**
```cpp
for(int i=1;i<=2*n-1;i++){
    s.clear();
    for(int k=1;k<=2*n;k++) s.insert(num[k]);  // 将数组元素存入 multiset
    s.erase(s.find(num[i]));
    s.erase(s.find(num[2*n]));  // 去除当前考虑的两个最大值
    ll x = num[2*n];           // 当前最大值
    cnt = 0;
    res[++cnt] = {num[i],num[2*n]}; // 保存这对最大值
```
- 枚举每一种可能的初始最大值对 \( \{num[i], num[2n]\} \)，其中 \( num[2n] \) 是数组的最大值。
- 将这两个数从集合 \( s \) 中移除，并保存这对到结果数组 \( res[] \)。

#### **3. 模拟匹配过程**
```cpp
for(int k=1;k<=n-1;k++){
    int temp = *prev(s.end());  // 获取当前集合中最大的数
    s.erase(s.find(temp));
    if(s.find(x-temp)!=s.end()){  // 检查是否存在与之匹配的数
        s.erase(s.find(x-temp));
        res[++cnt] = {temp,x-temp};  // 保存匹配对
        x = temp;                   // 更新新的目标和
    }
    else break;  // 如果找不到匹配的数，停止匹配
}
```
- 每次从集合中取出最大的数 \( \text{temp} \)，尝试找到与之匹配的数 \( x - \text{temp} \)。
- 如果匹配成功：
  - 将匹配的两数从集合中移除。
  - 将这对数加入结果数组。
  - 更新当前的目标和 \( x \) 为刚匹配的最大值 \( \text{temp} \)。
- 如果匹配失败（找不到 \( x - \text{temp} \)），提前退出匹配循环。

#### **4. 检查匹配结果**
```cpp
if(cnt == n) break;
```
- 如果形成了 \( n \) 对，说明成功完成匹配，提前退出枚举循环。

#### **5. 输出结果**
```cpp
if(cnt == n){  
    puts("YES");
    printf("%d\n",res[1].first +  res[1].second);
    for(int i=1;i<=cnt;i++)
        printf("%d %d\n",res[i].first,res[i].second);
}else puts("NO");
```
- 如果匹配成功：
  - 输出 "YES"。
  - 打印初始和 \( x \) 以及所有匹配对。
- 如果匹配失败，输出 "NO"。

---

### **核心思路**

1. **排序与初始对选择**：
   - 排序后，尝试选择数组中的每一个数 \( num[i] \) 和最大值 \( num[2n] \) 组成初始对。
   - 枚举所有可能的初始对进行验证。

2. **匹配规则**：
   - 初始对的和作为目标和 \( x \)。
   - 每次从剩余的数中找到当前最大的数 \( \text{temp} \)，并尝试匹配一个数 \( x - \text{temp} \)。
   - 匹配成功后，更新新的目标和 \( x \) 为当前最大值 \( \text{temp} \)。

3. **结果验证**：
   - 成功形成 \( n \) 对，则输出结果。
   - 若所有可能的初始对都无法成功匹配，则输出 "NO"。

---

### **时间复杂度分析**

1. **排序**：\( O((2n) \log(2n)) \)
2. **枚举初始对**：\( O(2n) \)，最多 \( 2n-1 \) 次尝试。
3. **匹配过程**：
   - 每次匹配需要从集合中查找和删除，复杂度为 \( O(\log(2n)) \)。
   - 最多匹配 \( n-1 \) 次。
4. **总复杂度**：
   - 单个测试用例复杂度为 \( O((2n) \log(2n)) \)。
   - 所有测试用例的总复杂度为 \( O(T \cdot (2n) \log(2n)) \)，其中 \( \text{sum of all } n \leq 10^6 \)。

---

### **示例**

#### 输入：
```
1
3
1 2 2 3 4 6
```

#### 处理步骤：
1. 排序：`[1, 2, 2, 3, 4, 6]`
2. 尝试初始对：
   - 初始对 \( \{2, 6\} \)，目标和为 \( x = 8 \)：
     - 匹配 \( 4, 4 \)，更新 \( x = 4 \)。
     - 匹配 \( 3, 1 \)，完成匹配。
3. 输出结果：
   ```
   YES
   8
   2 6
   4 4
   3 1
   ```

---

### **总结**

- 本算法通过枚举初始对并尝试匹配完成问题解决。
- 使用排序和 multiset 提供高效的查找与删除操作。
- 逻辑清晰，适合处理较大规模的数据输入。