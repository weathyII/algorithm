这个问题的关键在于，我们不需要任何算法来解决这个问题。现在，我们可以开始寻找遍历所有子串的方法，这样就不会退化为 O(n3)
 。

其中一种方法如下。如何检查子串 [l;r)
 是否是串联重复？让 d=r−l2
 .那么对于从 l
 到 l+d
 的所有 i
 来说， si
 应该匹配(要么相等，要么其中一个是问号) si+d
 。

如果先遍历子串的左边界，再遍历右边界，很多检查都会发生变化。但是，如果先遍历长度为 d
 的子串，然后遍历左边界，则会变得容易得多。从检查 [l;r)
 到检查 [l+1;r+1)
 有什么变化？去掉了一个校验： sl
 与 sl+d
 的匹配现在无关，因为 l
 不再属于子串。增加一项检查： sl+d
 匹配 sr
 是必需的，因为 r
 现在属于子串。

因此，解决方案如下：保持当前子串 [l;r)
 的成功检查次数。如果该值等于 d
 ，则子串是串联重复，可以用它的长度更新答案。否则，减去 l
 和 l+d
 的检查贡献值(如果成功则为 1
 ，否则为 0
 )，加上 l+d
 和 r
 的检查贡献值，然后继续到 [l+1;r+1)
 。

总体复杂度：每个测试用例 O(n2)
 。