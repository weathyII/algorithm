这段代码的核心是一个**动态加入点**的Floyd-Warshall算法变种，用于求解“恢复图最短路径和”的问题。以下是逐步的详细解释：

---

### 代码分析

#### 1. **全局变量定义**
```cpp
const int N = 510;
int a[N][N], d[N];
LL ans[N];
bool st[N];
```
- `N`: 定义最大顶点数，`510` 是上限。
- `a[N][N]`: 邻接矩阵，用于存储图中各顶点之间的距离。
- `d[N]`: 存储节点被加入图的顺序，`d[i]` 表示第 `i` 次加入的节点。
- `ans[N]`: 存储在每一步操作后，当前图中所有可达节点的最短路径和。
- `st[N]`: 表示某个节点是否已被加入图中。

---

#### 2. **输入数据**
```cpp
int n;
cin >> n;
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++) cin >> a[i][j];
for (int i = 1; i <= n; i++) cin >> d[i];
```
- 首先读取一个整数 `n`，表示图中节点数。
- 然后输入一个 `n × n` 的矩阵 `a`，表示节点之间的边权。
  - `a[i][j]` 是节点 `i` 到 `j` 的直接距离。
- 再输入一个长度为 `n` 的数组 `d`，表示节点加入的顺序。

---

#### 3. **逆序处理加入节点**
```cpp
for (int q = n; q > 0; q--) {
    int k = d[q];
    st[k] = true;
    ans[q] = 0;
```
- 采用**逆序**处理，即从最后一个节点加入开始（因为是动态加入图的过程）。
- `k = d[q]`: 取出当前要加入图的节点。
- `st[k] = true`: 标记节点 `k` 已加入图中。
- 初始化 `ans[q] = 0`，用于累计当前所有已加入节点间的最短路径和。

---

#### 4. **更新最短路径**
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        a[i][j] = min(a[i][j], a[i][k] + a[k][j]);
        if (st[i] && st[j]) ans[q] += a[i][j];
    }
}
```
- **三重循环更新最短路径**:
  - 对于所有顶点对 `(i, j)`，检查是否经过新加入的顶点 `k` 会使路径更短。
  - `a[i][j] = min(a[i][j], a[i][k] + a[k][j])`: 更新 `i` 到 `j` 的最短路径。
- **累加最短路径和**:
  - 只有当 `i` 和 `j` 均已加入图（即 `st[i] == true` 且 `st[j] == true`）时，才将 `a[i][j]` 累计到 `ans[q]`。

---

#### 5. **输出结果**
```cpp
for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
```
- 最后按顺序输出每次加入一个节点后，当前图的最短路径和。

---

### 核心思想

这段代码解决的是一个动态求解图的最短路径和的问题，其关键点是：
1. 使用 **Floyd-Warshall 算法**更新全局最短路径。
2. 逆序处理节点加入顺序，确保先加入的节点对后续计算不产生干扰。
3. 在每次更新后，仅对当前加入图的节点集合计算最短路径和。

---

### 示例讲解

**输入：**
```
4
0 3 1 1
3 0 1 2
1 1 0 4
1 2 4 0
4 3 2 1
```

1. 图中有4个节点，邻接矩阵为：
   ```
   0 3 1 1
   3 0 1 2
   1 1 0 4
   1 2 4 0
   ```
   加入顺序为：`4 -> 3 -> 2 -> 1`。

2. **逆序计算：**
   - 初始：加入节点4。
   - 第二步：加入节点3，更新最短路径。
   - 第三步：加入节点2，再次更新路径。
   - 第四步：加入节点1，最终更新并计算总和。

**输出：**
```
20 12 8 0
```

解释：`20, 12, 8, 0` 分别是每次加入节点后的最短路径和。