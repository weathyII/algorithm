请注意，由于树有 a+b+c
 个顶点，因此所有顶点都有 0
 、 1
 或 2
 个子顶点。如果一个顶点没有子顶点，则称其为叶顶点。

这样做的目的是通过每次添加一个或两个顶点，让树从根部 "生长 "起来。形式上

从根(最初是叶子)开始。
在叶子上重复添加 1
 或 2
 个顶点。总共添加 2
 个子节点 a
 次和 1
 个子节点 b
 次。
事实证明，在这个过程结束时，叶子的数量是预先确定的：

每增加一个 1
 子代，叶子的数量都不会改变(因为我们会失去一片叶子，同时增加一片叶子)。
每增加一个 2
 子代，叶子的数量就会增加一片(因为我们失去了一片叶子，得到了两片叶子)。
最初只有一片叶子。因此，在这个过程结束时，我们需要 c=a+1
 才能使这棵树有效。如果不是，那么答案就是 −1
 。

否则，我们需要最小化高度。我们的想法是贪婪的：请注意，当我们可以选择时，我们应该始终按照 2
 而不是 1
 来增长，因为很明显这会严格地降低高度。同样，我们也应该始终选择最靠近根节点的节点，以尽量减少高度。

因此，我们可以模拟上述过程，先种植 2
 ，后种植 1
 ，这需要 O(a+b+c)
 个时间。

奖励：你能在 O(log(a+b+c))
 时间内解决这个问题吗？或者更好？

关于实现的注意事项 你可以在两个变量中存储当前层和下一层的 "空闲 "节点数，也就是说，你根本不需要存储整棵树。在遍历当前层时，存储下一层的节点数。